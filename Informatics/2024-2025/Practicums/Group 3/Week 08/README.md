# Седмица 8
# Предефиниране на оператори - основни концепции. Бинарни оператори.



# Задача 1

![Static Badge](https://img.shields.io/badge/easy-green)

Създайте програма, в която има реализиран клас `Date`, който пази в себе си информация за следните променливи:

* Ден - поле от тип `std::uint8_t`;
* Месец - поле от тип `std::uint8_t`;
* Година - поле от тип `std::uint16_t`.

Класът не трябва да притежава конструктор по подразбиране. Също така класът трябва да има следните реализирани методи:

* параметризиран конструктор, който приема параметри за ден, месец, година;
* селектори за всички полета;

Класът ви трябва да има следните предефинирани методи:

* оператор `==` за сравнение
* оператор `!=` за сравнение


# Задача 2

![Static Badge](https://img.shields.io/badge/easy-green)

Майстор Череша е изпратил Пинокио да събере ябълки от специално дърво в гората. За целта той дал на Пинокио кошница. Но, както сами се досещате, това не била каква да е кошница, а магическа. В какво се състояла магията на кошницата, дадена на Пинокио ли? Тя могла да побира произволно количество ябълки. Ябълките представляват символни низове, заделени с точна големина, както и самата дължина. Тази кошница, която вие трябва да направите, е такава, че, ако в даден момент в кошницата на Пинокио има `N` ябълки, то тя може да има свободно място за най-много още `N` ябълки. Кошницата на Пинокио трябва да позволява добавянето на нова ябълка и премахването на ябълка по даден низ, който я описва. Реализирайте следните оператори за кошницата на Пинокио:

* оператор [] - по зададен индекс, ако той е валиден, връща ябълката, което се намира там.
* оператор [] - по зазаден символен низ, връща първата ябълка, което я съдържа, ако има такова.
* оператор + - конкатенира 2 различни кошници.
* оператор + - конкатенира низ с всички ябълки в дадена кошница.
* оператор += - конкатенира 2 различни кошници.
* оператор += - конкатенира низ с всички ябълки в дадена кошница.


# Задача 3

![Static Badge](https://img.shields.io/badge/easy-green)

Създайте програма, в която има имплементиран клас, който представлява `N`-мерен вектор, като `N` може да бъде произволно голямо число (`unsigned int`). Всеки от компонентите на вектора е от тип дробно число - `double`. Имплементирайте следните оператори:

* Оператор [], който приема аргумент цяло число индекс, и връща съответният компонент на този индекс, при достъпване на грешен компонент се връща `0`.
* Оператор + - извършва събиране на вектори с еднаква размерност.
* Оператор - - извършва изваждане на вектори с еднаква размерност.
* Оператор += - извършва събиране на вектори с еднаква размерност.
* Оператор -= - извършва изваждане на вектори с еднаква размерност.
* Оператор * - извършва умножение на вектор с число (скалиране).
* Оператор *= - извършва умножение на вектор с число (скалиране).
* Оператор / - извършва деление на вектор с число (скалиране).
* Оператор /= - извършва деление на вектор с число (скалиране).


## Задача 4

![Static Badge](https://img.shields.io/badge/easy-green)

Създайте програма, в която има имплементиран клас, който представлява обикновена дроб `Rational`. Обикновената дроб, както знаем има числител и знаменател - това са цели числа. Предефинирайте необходимити оператори за класа:

* Оператор + събира две обикновени дроби.
* Оператор - изважда две обикновени дроби.
* Оператор * умножава две обикновени дроби.
* Оператор / дели две обикновени дроби.
* Оператор == сравнява две обикновени дроби са еднакви.
* Оператор != сравнява две обикновени дроби са различни.
* Оператор <, който имплементира поведението на релацията "по-малко".
* Оператор >, който имплементира поведението на релацията "по-голямо".
* Оператор <=, който имплементира поведението на релацията "по-малко или равно".
* Оператор >=, който имплементира поведението на релацията "по-голямо или равно".
* Оператор += събира една обикновена дроб към друга.
* Оператор -= събира една обикновена дроб към друга.
* Оператор *= събира една обикновена дроб към друга.
* Оператор /= събира една обикновена дроб към друга.


## Задача 5

Да се реализира изброим тип `Currency`, който да пази следните стойности: `BGN`, `USD`, `EUR`. Напишете структура `ConversionRate`, която ще съдържа следната информация: обменен курс, стара валута, нова валута. Валутите са от тип `Currency`. Да се реализира клас `Money`, който да пази в себе си следната информация: сума пари и вид валута. Класът да има следния интерфейс:

* Забранен конструктор по подразбиране.
* Параметризиран конструктор.
* Селектори на данните на класа.
* Забранени мутатори за данните на класа.
* `softConvert(const ConversionRate& convertion) const` - не променя стойностите на класа, но променя копие на класа и връща него.
* `hardConvert(const ConversionRate& newCurrency)` - променя самия клас.
* Предефинирани оператори за събиране и изваждане с реални числа.
* Предефинирани оператори за събиране и изваждане с обекти от тип `Money`.
* Унарен оператор `-`, така че, като е поставен пред обекта, да обръща неговата стойност.
* Предефинирани оператори за наредба.

Да се реализира клас `Client`, който да пази в себе си следната информация: име - символен низ с точна големина, ЕГН, рожден ден, пари - обект от тип `Money`. Класът да има следния интерфейс:

* Параметризиран конструктор.
* Необходимите селектори и мутатори.

Създайте клас `Bank`, който да пази в себе си следната информация:

* име на банката - символен низ, заделен с точна големина.
* потребители - саморазширяващ се масив от `Client`.
* големина на потребителите
* капацитет на потребителите
* обменни курсове - масив от точно `6` обекта от тип `ConversionRate`. Трябва да има обменен курс от всяка валута към всяка друга.


Класът да има следния интерфейс:

* Забранен конструктор по подразбиране
* Параметризиран конструктор
* `addClient`
* `removeClient`
* `getClientIndex`
* `deposit`
* `withdraw`
* `transfer` - първо трябва да се провери дали съществуват клиентите, после дали `source` клиентът има достатъчно пари да прехвърли към `destination` клиента. После маха парите от `source` и ги дава на `destination`. При различни валути може да се наложи конвертиране на парите.
* `convertClientMoney`

Класът `Money` са притежава оператори `<<` и `>>` за вход и изход. Класът `Money` да бъде събиран с числа от тип `int` и `double` комутативно. При събирането числото се прибавя към сумата. Класът да може да бъде преобразуван към `int` и `double`.


## Задача 6


## Задача 7


## Задача 8


## Задача 9


## Задача 10


## Задача 11


## Задача 12


## Задача 13
